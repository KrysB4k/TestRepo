<DOCTYPE !html>
<html>
  <head>
    <title>Introduction</title>
  </head>
  <body text=#000000 bgcolor=#FFFFFF link=#0000FF alink=#0000FF vlink=#0000FF>
    <link rel="stylesheet" href="intro/intro.css"/>
    <script src="intro/introparts.js"></script>
    <canvas id="draw" onclick="cycleMode()" style="border-bottom: 10px ridge gray">
      <script>
        "use strict";
        canvas = document.getElementById("draw");
        canvas.width = window.innerWidth;
        canvas.height = 500;

        ctx = canvas.getContext("2d");
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        offscr = new OffscreenCanvas(128, 128);
        offctx = offscr.getContext("2d");

        setupPartArray();

        setInterval(createParticleLoop, 20);
        setInterval(manageUpdateDrawLoop, 20);
      </script>
    </canvas>
    <noscript>
      <img style="display: block; margin-left: auto; margin-right: auto;" src="intro/logo_black.png">
    </noscript>
    <div style="margin: 48px;">
      <table width=100%, style="margin: 0;">
        <tr>
        <td>&nbsp;</td>
        <td style="text-align:right"><a href="LuaManual.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
        </tr>
      </table>
      <h1>Introduction</h1>
      <p>Welcome to the particle scripting tutorial series!<br><br>
      The <strong>Particle System Plugin</strong> adds a very flexible particle engine to the TRLE. In other words, it introduces a dynamic particle system for the creation of user-defined particle effects, somewhat reminiscent of Unity, Unreal or other popular game development suites (though notably offering less functionality and far less performance; the aged TRLE engine imposes restrictions that are difficult to mitigate without extensive modification to the game’s code). The particle system is interfaced through a dedicated <strong>Particle Scripting API</strong> (<i>Application Programming Interface</i>) utilizing the <strong>Lua</strong> programming language, separate from the TRNG scripting interface you may be familiar with.<br><br>
      In this series of text-based tutorials, assisted with visual aids including graphics, animated GIFs and videos, my goal is to show you around the particle system and the scripting necessary to utilize it. It is aimed both at TRLE users who have some background with Lua or programming, as well as users who don’t have any. The only requirement, aside from an eagerness to learn, is to have some well-established knowledge about TRLE and TRNG itself, so the target audience are seasoned level builders who are looking to add new kinds of visual effects (and more!) to their levels. The tutorials are not really suitable for novice builders though, as an assumption is made that the reader is already familiar with the level building process in general, what are some of the essential file formats involved in building (such as .wad or .wad2, .prj or .prj2, .tr4), what sprite textures are and where they can be located in the wad files, etc. I would not advise continuing if you are not a knowledgable builder who has been tinkering with the level editor for at least a year and has dabbled with TRNG scripting to some extent (don’t want to discourage or hold you off, but following along may prove tough in any other case!)<br><br>
      Keep in mind that the tutorials do not showcase every single feature and facet of the plugin, otherwise this tutorial series would triple in length (and it’s considerably long as it is, already). The <strong>Particle Scripting API</strong> documentation is meant to be the supplementary source of information for whatever is left out of the tutorials, giving a dry and technical, but rigorous coverage (TRNG users: think of it as the equivalent of the <strong>Reference</strong> tab in NG Center).<br><br>
      The first section of the introduction will discuss why Lua was the optimal choice for this plugin, in spite of most TRLE builders not being familiar with it. The second section will introduce the two faces of the plugin’s scripting interface, reflecting the two categories of users for this plugin, those being the “builder” (a person that casually uses effects created by other users) and the “programmer” (a person writing their own effects with Lua). Of course you, as a real user, may belong to the first, second or both categories. The builder’s interface will be described first and the programmer’s interface will be described afterwards. The second section about the plugin’s particle system gives a theoretical background to how the particle system operates. From that point, the focus fully shifts to the programming interface and remains that way through the remaining sections and for the rest of the whole tutorial series (so only the first two or three sections here are of relevance to “builders”). The subsequent sections deal with technical overviews of particles, particle groups and the types of particles supported by the plugin.<br><br>
      The after this introduction comes the <strong>Lua Crash Course</strong> – a condensed, quick overview of Lua’s syntax and most important features. Afterwards, we will be moving on to practical scripting tutorials in <strong>Chapter 1</strong> and all later chapters. There, I proceed to give step-by-step instructions on how to script a variety of particle effects from scratch and how to use the plugin’s features. I start with a very basic, easy effect in the first chapter and move onto increasingly complex and intricate ones, explaining more and more of the particle system’s features along the way. After the tutorial’s main chapters come the <strong>Case Studies</strong>, which will showcase the possibilities of combining proficient particle scripting with advanced TRNG features, elevating the particle system to its maximum potential. The provided examples demonstrate a diverse range of different effects that can be achieved through the scripting system in tandem with TRNG and / or other plugins. You can use these examples as template scripts for your own effects. And again, the <strong>Particle Scripting API</strong> documentation fills you in on all the remaining features that might not be covered in the tutorials.</p>
      <hr>
      <h2>Sections</h2><strong>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id1">1. The elephant in the room: why Lua and not TRNG scripting?</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id2">2. The user interfaces</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id3">3. The particle system</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id4">4. Particles</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id5">5. Particle Groups</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id6">6. Categories of particles</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id7">7. On the copy-pasting of code</a></strong>
      <hr>
      <a name="id1"><h3>The elephant in the room: why Lua and not TRNG scripting?</h3></a>
      <p>Understandably, the decision to have dedicated scripting for what seems to be “just another plugin”, in a language mostly unfamiliar to the target audience of TRNG level builders may seem off-putting. However, we (the authors of this plugin) can assure you that the decision to use Lua was for the best.<br><br>
      The initial development phases of this plugin indeed used TRNG script commands, such as <span class="var">Customize</span> and <span class="var">Parameters</span>. Unfortunately, due to the hindering nature of TRNG syntax and lack of dynamic scripting features, working with the particles in this environment made for a very clunky interface that hampered the potential this plugin had. Since TRNG relies on using numbers, flags and constants which cannot change after building the script, it becomes difficult to implement things like random values or convey complex logic effectively in such a system. Additionally, using TRNG would require to create countless different CUST_ or PARAM_ constants, each describing a new shape or property of the particle.<br><br>
      For example, say we would like a feature where particles are spawned in a circular formation. We could have a <span class="var">PARAM_PARTICLE_CIRCLE</span> that allows to set up the parameters of this circle. What if someone would want an oval shape? <span class="var">PARAM_PARTICLE_CIRCLE</span> would have to be modified to accomodate this, or a new <span class="var">PARAM_PARTICLE_OVAL</span> constant would have to be added. Then, someone would like a spiral shape, in addition to the circle and oval, requiring yet another constant. Then for a sphere shape, we would need another constant. Then another constant for a box shape. Soon enough, these PARAM_ constants will be in the hundreds or even thousands, each with dozens of parameter fields, yet still not account for every possible kind of shape or property of the particle.<br><br>
      Another factor deciding against TRNG scripting is that the syntax does not make it obvious which value accounts for what property. Let’s look at a real example this time, of a PARAM_ constant that used to be in one of the first iterations of the plugin:<br><br>
      <span class="var">Parameters= PARAM_MAGIC_FIRE, 1, 160, 64, 128, 1, 255, 1, 128, 64, 128, 1, 196, 64, 160, 64, 96, 64, 196, 64</span><br><br><br>
      Everything clear with this <span class="var">PARAM_MAGIC_FIRE</span> and what each of the various numbers mean? To have any glimpse of an idea, you’d have to look up the Reference entry for <span class="var">PARAM_MAGIC_FIRE</span> to see the syntax, or look at the syntax prompt in NG Center or TombIDE, but even then it can still be confusing with so many parameters listed one after another in a single line. Sadly, when you have so much customizability in a single feature, the TRNG syntax falls flat on its face. And this is just a single PARAM_ constant we’re talking about, meanwhile there would probably be several dozens if not hundreds with a comparable number of parameters in each. There are simply far too many different properties for this TRNG syntax to be effective in its job.<br><br>
      Creating particle effects benefits greatly from dynamic scripting features that TRNG simply lacks. Keeping the particle interface within the TRNG realm would only hold back this plugin’s true capabilties. Exactly for this reason, we turned to Lua, which combines all the descriptive possibilities TRNG could ever offer, augmenting it with useful programming concepts, such as variables, loops and functions. It really cannot be overstated how much this increased the usability of the plugin and all of its features. In fact, the plugin was pushed into completely new territories as a result of this, becoming a much bigger and ambitious project then it ever was meant to be initially. This culminated into it becoming the powerful particle engine, which you are reading the manual of right now.<br><br>
      Of course, there will always be those users for whom programming syntax remains too esoteric to grasp. A possible middle-ground would be to implement a visual interface for designing particle effects, but such graphical user interfaces take a lot of time to develop. Therefore, the current particle system interface remains entirely scripting-based (although we don’t rule out a graphical interface at some unspecified point in the future). For this reason, we have decided to separate the plugin’s user interface into two distinct, but correlated interfaces: one for the user who will design particle effects with Lua code (hereby referred to as the “programmer”) and the other for the user who will utilize effects coded by programmer users (hereby referred to as the “builder”) with a much simplified syntax, not reliant on programming knowledge whatsoever. The actual users of the plugin can of course be programmers, builders, or even both at once, designing their own effects and using them in their TRLE projects at the same time.</p>
      <hr>
      <a name="id2"><h3>The user interfaces</h3></a>
      <p>There are two separate scripting interfaces. EffectsLibrary.lua containing the Lua code for the particle’s appearance and behavior, and levelname.lua files (e.g. settomb.lua, karnak.lua) with the simplified builder’s interface for using these effects within a level.<br>
      I will describe the level builder’s interface first. Each level file (.tr4) is paired with a corresponding Lua scipt file (.lua) bearing the same name. In case such a file is not present, the plugin understands that the level uses no custom particle effects. Otherwise, if a matching .lua file exists, it will read it as the level is loaded (or reloaded in case of a savegame). This lua file contains commands to customize the particle effects existing within the general EffectsLibrary.lua file. The available customization are depended on the particle effect’s programmer. The programmer may for instance decide to make the sprite texture and color customizable for the effect. In such case, the customization command for that effect will give the option to change the sprite texture and color. These parameters can also be more abstract, like the max velocity at which the particle can travel, it depends entirely on what the programmer chooses to make customizable in the level builder’s interface.<br><br>
      On the other hand, the programmer’s interface is contained within the general EffectsLibrary.lua file. Here, as a programmer, you have the ability to define custom particle effects which you can use yourself or give to level builders. This interface is far more complex than the level builder’s interface, but allows to design virtually any kind of effect from scratch. How to use this programmer’s interface will be the main topic explored through the entire tutorial series.
      We will now move to describing the two fundamental ideas behind the particle system, which are particles and particle groups. This information is mandatory for programmers who will be working on new effects. However, having a general understanding can be helpful to non-programming level builders too.</p>
      <hr>
      <a name="id3"><h3>The particle system</h3></a>
      <p>The particle system operates from within the <strong>Plugin_ParticleSystem.dll</strong> (surprise, surprise). You, as the user, can interact with it through the <strong>Particle Scripting API</strong> in the Lua language. This lies at the foundation of working with particles. Getting a hold of Lua and the scripting API is mandatory knowledge if you want to create your own effects with it. However, prior to all of that, one must understand the theoretical concepts behind the particle system in the first place. For the casual “builders” out there, I would advise you to read this one extra section as well, it won’t hurt and could perhaps give more insight into how this all works.<br><br>
      There are two very important, crucial concepts to know of in context of the particle system. These two concepts are:
      <ul><strong>
      <li>Particles
      <li>Particle Groups
      </strong></ul>
      Particles are objects which are a representation of some visual effect. Particles already existed in the classic TR engines in several forms, examples including smoke, steam, flames, blood, bubbles, snow and rain, to name just a few. You can picture a particle as some individual entity, with a position, velocity, color and sprite texture, which is a component of some greater effect, like a fire or snow storm. We will call a single such particle a particle instance. You should remember this definition – a particle instance is a singular particle entity of a broader collection of particles.<br><br>
      Particle Groups are a way to categorize particles by “type”. To relate this to classic TR again, you can see that when comparing fire particles with snow particles, not only do they appear differently from each other, but also exhibit different behavior. By using our terminology, we can say that fire particles belong to a different particle group than snow particles.
      Another way to look at it is to compare this to enemies and their slots. Notice how some enemy, e.g. from the BADDY_2 slot, has some individual characteristics, such as position, remaining health or the animation he is currently performing. These are all true for that specific instance of Baddy, but not necessarily true for other instances (after all, a second baddy can be somewhere else, have a different amount of health left, or can be performing a different animation). However, there are also traits that all BADDY_2 will share with each other, such as their appearance or the general behavior/AI. Let’s relate this back to particles. A particle instance can have a unique position, velocity or color, but as a member of a particle group, it shares the same behavior with other particle instances of the group.<br><br>
      As we have defined Particles and Particle Groups on a surface level, it’s time to move to the technical aspects of how both work. Particles and their respective groups form the core concept of the particle scripting framework, so make sure you understand them and the relation between them before moving on.<br><br>
      Note to “builders”: onwards from this section begin the more scripting-related details of particles and the particle system for the “programmers”, but if you were intrigued enough to read more, feel free to continue! You may find yourself creating custom particle effects in no time!</p>
      <hr>
      <a name="id4"><h3>Particles</h3></a>
      <p>Particles have many properties that define them, but I will describe the most essential ones for now, which characterize practically all particles:</p>
      <ul>
      <li><strong>Group</strong> – The particle group to which the particle instance belongs.
      <li><strong>Position</strong> – 3D vector (which can also be thought of as a point in 3D space), describing the (X, Y, Z) coordinates of the particle instance in the game world.
      <li><strong>Velocity</strong> – 3D vector describing the (X, Y, Z) components of velocity (i.e. how many units of space the particle instance travels on each axis per each frame in-game).
      <li><strong>Acceleration</strong> – 3D vector describing the (X, Y, Z) components of change to velocity (i.e. by how many units the velocity will change on each axis component, per frame). Positive Y acceleration can be imagined as the force of gravity pulling the particle towards the ground. The 3D vector allows to generalize this idea of force to all directions.
      <li><strong>RoomIndex</strong> – this property is mostly relevant if the particle will be detecting collisions (e.g. with room geometry or with objects) and is otherwise omittable.
      <li><strong>LifeSpan</strong> – How much total life the particle instance starts out with. The particle’s LifeCounter also starts out with this value at first.
      <li><strong>LifeCounter</strong> – The current amount of life the particle instance has. The value is always between LifeSpan and 0, i.e. 0 <= LifeCounter <= LifeSpan. On each in-game frame, the LifeCounter is decreased by 1. Once it reaches 0, the particle instance dies and is no longer drawn or updated.
      </ul>
      Depending on the category of particle, it will have additional or different properties not described above, which will be covered later.<br><br>
      As you can tell, many of these properties sound vaguely mathematical. I have to set the scene and make it clear than particles are indeed very mathematical objects. It’s not really possible to design particle effects without knowing at least a bit of math. Fortunately, all of the mathematics needed to work with particles (almost) never go beyond what you've learned in high school. And even then, most of it fits within elementary math education. For very simple effects like e.g. dust moving across a room, it’s no different to working with FLEP smoke emitter OCBs – you simply assign some number values to different fields, albeit with a new syntax. In this case, you don’t need to know math beyond just knowing how numbers work.<br><br>
      Since the scripting uses Lua as its language of choice, the mathematics are done with Lua’s coding syntax (and as such, math = code). A general rule of thumb is: the fancier-looking the effect, the more math/code is involved, at least most of the time. If you were to make a homing missile that will track down Lara and explode on impact, for example, then it should seem logical that it will require more coding effort than some ambient, drifting dust particles. But the good news is that the plugin’s <strong>Particle Scripting API</strong> offers several specialized, ready-to-use functions which can perform the more mundane and commonly needed calculations for you. This way, you don’t have to go through the effort of coding from scratch a function that will make the particle follow some item, for instance.<br><br>
      We’ve established the basic properties of particles, now let’s talk about particle groups.</p>
      <hr>
      <a name="id5"><h3>Particle Groups</h3></a>
      <p>A particle group (simply called a “group” in context) stores data that characterizes all of the particle instances belonging to said group. As in the analogy to object slots, it describes common behavior of its particles. Thinking of a fire as a group of particles, the particle instances may have different positions, velocities, rotations, variations in color and size, but all will follow the general pattern of moving upwards and shrinking. So we can observe a general behavior by which we can identify this group, even if it manifests itself in different ways (from a flame emitter, a burning torch or when Lara herself is on fire).<br><br>
      How could you describe this particle behavior to a program, though? As is often the case in programming, the behavior of objects is controlled by functions, which manipulate the data of said objects to make them behave in a certain way, to react or make decisions while the program is running. Effectively, we can control the behavior of particles belonging to a group by providing such functions to this group.<br>
      There are two types of functions a group can have:
      <ul>
      <li>the <strong>initialization (init) function</strong>
      <li>the <strong>update function</strong>
      </ul>
      The initialization function (init function for short) has the main goal of providing a set of instructions on how to initialize a particle of the group when it is spawned into the game world. It can set the particle’s initial position, velocity, size, color and any other properties it may have (in other words, it provides a blueprint for creating particles of the group). Usually, this function is executed once on each game tick (frame).<br><br>
      The update function is a highlight feature of this plugin, making it extremely versatile and flexible for users. The update function is also performed on each game tick, but not just a single time – it’s performed for every currently existing particle instance belonging to the group. The function allows to access the particle’s properties and manipulate them on the fly, per each frame, during the course of the particle’s life.<br><br>
      The ramifications of update functions are impossible to condense into just one paragraph, but in a nutshell, this means that you have full programming control of what all the particles belonging to the group are capable of doing at any point in time. Whatever you command the particle to do, it will do. This is a significant change of paradigm compared to FLEP smoke emitters, where you had little influence over how the particle was supposed to behave after being spawned (aside from being able to set some flags, for example to do contact damage or to set Lara on fire).<br><br>
      To give you a very brief idea of what’s possible with the update functions, you can create particles that animate through a looping sequence of sprites or meshes, particles that follow Lara (or any other objects) around the level, particles with basic physics, which collide with walls, floors and objects, particles that travel along mathematically defined curves (such as helices, waves or even more complex shapes), particles with dynamically changing properties like colors or sizes, e.g. in response to the distance from Lara or the number of enemies near her, particles that harm, heal, poison, set on fire or explode on contact, particles that can spawn other particles, which in turn spawn even more particles, or particles that trigger a timed door sequence when coming into contact with a <strong>MUMMY</strong>, but only if Lara also has Puzzle Item 4 in her inventory and she's currently monkey-swinging – totally absurd (or perhaps not, you decide)! This is a modest fraction of all that can be done with particle update functions.<br><br>
      There are also several useful settings and options of particle groups, which will be covered in later chapters.</p>
      <hr>
      <a name="id6"><h3>Categories of particles</h3></a>
      <p>I have described particles very generally up to this point, but as I have hinted at already, there is more than one category of particle within the particle system. This is because particles are more than just a position, velocity and lifetime, there must also be a graphical object drawn at that position. This graphical object also needs to be described in some way to the plugin, so it will know what to draw on screen to represent the particle. There are two different categorizations we can apply to particles. The first categorization asks: what is the particle’s graphical object – is it a sprite or a mesh?</p>
      <h4>Sprite particles vs. Mesh particles</h4>
      <p>Sprite particles should seem quite familiar, almost all particle effects seen in the classic TR engines fall into this category. Smoke, fire, steam, blood, snow, underwater dust, bubbles – all of these are represented by a sprite texture with some possible coloration to it. The textures for these effects reside in the DEFAULT_SPRITES slot. There is also a special subtype of sprite particles in the engine, which are line-like with only color and no sprite texture (as seen with rain, drips coming off Lara after swimming, ricochets on walls when shooting guns, etc). Even though they do not use any sprite texture, they are classified as sprite particles nonetheless. Both (textured) sprite particles and (textureless) line particles are supported by the particle system plugin and can be used as the particle type for your effect.<br><br>
      Mesh particles are particles represented by textured meshes from objects. These are not nearly as common, since in the classic engines meshes are mostly reserved for moveable items and statics. But if you look closely, you will see some examples of mesh particles as well: gunshells from Lara’s guns, the little beetles coming from the beetle emitter and locusts from the locust emitter, various projectiles shot by enemies like Demigod or Setha – are all forms of mesh-based particles.
      In classic TRLE, the builders never had any means of controlling these mesh-based effects beyond changing the mesh itself and could only rely on predetermined behaviors coded into the engine. They could not be manipulated by any other means, not even TRNG nor FLEP patches offering any ways of doing so.<br><br>
      In comes another big feature introduced by the plugin’s particle system – for the first time ever, you are given access to fully customizable mesh-based particles! They can be manipulated with init and update functions and used for all kinds of different effects, just like sprite particles. There are certain distinctions between them and sprite particles though, which will be explained in their respective chapters later in the series.<br><br>
      Another categorization of particles, completely unrelated with sprites or meshes, is dividing them into world-space particles and screen-space particles.</p>
      <h4>World-space particles vs. Screen-space particles</h4>
      <p>What do these terms even mean: world space and screen space?<br><br>
      Simply put, world space is the three-dimensional space you see when playing the game, viewed through the game screen. It is characterized by the X, Y and Z axis, each axis representing one of the 3 dimensions. Practically all particles encountered in the engine fall into this category, as they all are described by a 3D position coordinate.<br><br>
      What about screen space? Well, we mentioned that we are viewing this 3D world through a screen. This screen is flat and two-dimensional, and as such is described by just X and Y coordinates, which you may think of as pixels for simplicity. In order to represent the 3D space on a 2D screen, during the rendering phase, the engine performs calculations to project this virtual 3D world onto the 2D screen. In the process, the 3D coordinates are “flattened” to 2D. The new X and Y coordinates obtained in the process now mean something completely different, that being on which part of the screen the object appears.<br><br>
      So, what if we imagined particles which do not reside in the 3D game world, but instead existed on the 2D world of the game screen? Well, this is exactly what screen-space particles are! As yet another novel feature offered by this plugin, you are able to spawn sprite or mesh particles onto the game screen itself, as a foreground to whatever is going on in the 3D world. Through their particle group, you can assign init functions and update functions to fully control their behavior, same as with world-space particles. The only difference is that this no longer takes place in the 3D world, but instead on the game screen’s 2D world. You can perhaps see this feature being quite useful to simulate things like raindrops falling onto the camera lens and sliding down, or Lara’s vision becoming bloodshot as she sustains injuries, or whatever other idea you may be imagining now.<br><br>
      Screen-space particles require somewhat different handling and considerations by the particle programmer, when compared to the ordinary world-space particles. But you can be assured, these aspects will be explained in later sections of the tutorial series, too.<br>
      The categorizations between sprite/mesh and world/screen are not correlated whatsoever, meaning that you can have sprite/world-space particles as much as you can have mesh/screen-space particles (and vice-versa).</p>
      <hr>
      <a name="id7"><h3>On the copy-pasting of code</h3></a>
      <p>Across the various pages of the tutorials, I will be providing snippets of Lua which may or may not be functional pieces of code. I know many of you will probably resort to copying & pasting the code the moment you see it. However, I would advise you against doing so. First of all, the code may not even work, but simply be a demonstration of what <u>NOT</u> to do. Second of all, you will not learn as much if you resort to copy-pasting everything.This is tried and tested when it comes to coding in general, you will learn considerably more, not only about the syntax, but also to think in the language you’re dealing with, when you write the code yourself, line by line, instead of copy-pasting without even thinking about what you’re copying and what it does.<br>
      In spite of what I just said, for longer snippets that do actually work, I’ll provide a special button that will be located in the top right corner of the code block:&nbsp;&nbsp;&nbsp;&nbsp;<img style="border: 2px solid black; border-radius: 8px; background-color: #B0F0B0; padding: 0 5px;" src="clipboard.png"><br>which will copy the code displayed in the snippet to clipboard with a single click. Treat this as more of a convenience when you need to quickly compare the reference implementation to your own, rather than for avoiding putting in effort. I really can't stress enough how important it is to type the code yourself if you want to become a proficient user of this plugin and create jaw-dropping particle effects!
      </p>
      <hr>
      <p>With the theoretical background out of the way, we can slowly approach scripting our first particle effect. Before we get there, though, I’d like to explain the basics of Lua as a programming language for those unfamiliar with it in the upcoming <strong>Lua Crash Course</strong>. Even to the readers that already know a thing or two about Lua, I would highly recommend glancing through it, as I bring up some specific quirks of the scripting used in this plugin (such as the lack of global variables).</p><br>
      <table WIDTH=100%>
        <tr>
        <td>&nbsp;</td>
        <td style="text-align:right"><a href="LuaManual.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
        </tr>
      </table>
    </div>
  </body>
</html>
